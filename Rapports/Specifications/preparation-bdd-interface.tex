\section{Préparation des données}

Cette partie du projet a pour but de réaliser un premier traitement sur les
données d’entrée. Ces données sont aux formats GEDI et PiFF, présentés dans
le dernier rapport. Nous devons fournir un logiciel qui soit capable de
traiter ces formats (\textbf{PR\_FO\_1} et \textbf{PR\_FO\_2}). Nous avons validé
la proposition que nous avions faite, qui était de choisir PiFF comme format
de traitement unique. Nous fournirons donc un convertisseur de GEDI vers PiFF,
et nous garantirons par modélisation logicielle la possibilité pour les futurs
utilisateurs d’écrire d’autres convertisseurs des formats de leur choix vers
PiFF s’ils le souhaitent (\textbf{GEN\_EVOL}).

\paragraph{}
En exploitant le fichier PiFF, ce module du projet génèrera les imagettes qui
formeront les exemples. Les coordonnées utilisées pour la découpe d’image seront
calculées grâce au polygone identifiant le paragraphe présent dans le fichier
d’entrée, ainsi que les détecteur de lignes. Cette découpe pourra être réalisée
soit en lignes, soit en paragraphes, ce qui correspond à deux reconnaisseurs
différents à utiliser par la suite. Par ailleurs, les fonctions de manipulation
d’images utiliseront la bibliothèque graphique \href{https://opencv.org}{OpenCV},
que nous avions déjà sélectionnée auparavant. Les deux options seront
disponibles sur le logiciel.

\paragraph{}
Nous devrons récupérer la vérité terrain si elle existe dans le fichier d’entrée,
afin de pouvoir l’afficher sur l’IHM et permettre à l’utilisateur de la corriger
ainsi qu’au reconnaisseur de s’entraîner avec, en lui fournissant des exemples
que notre logiciel aura créés en associant les imagettes à leur transcription.

\section{Base de données}

\subsection{Choix du type de modélisation}

Concernant le stockage des données, nous avions plusieurs choix :
\begin{itemize}
\item écrire dans des fichiers ;
\item installer une base de données sur un serveur distant ;
\item installer une base de données sur un serveur local à la machine ;
\item installer une base de données sans serveur, en interne au logiciel.
\end{itemize}

\paragraph{}
Pour éviter d’utiliser un système de base de données, nous aurions pu choisir
d’écrire les données que l’on voudrait sauvegarder directement dans des
fichiers. Cependant, cette façon de sauvegarder les données n’est pas très
“propre” et est compliquée à structurer. C’est pour cette raison que nous nous
sommes plutôt dirigés vers un Système de Gestion de Bases de Données (SGBD).

\paragraph{}
Utiliser un serveur distant sur lequel on installerait une base de données
était notre première idée. Cependant, ce système possède un inconvénient
majeur qui est que notre application aurait besoin d’une connexion Internet
et d’un serveur pour fonctionner. Cette contrainte ajoutant plus de complexité
que nécessaire, nous n'utiliserons pas de serveur distant. Utiliser un serveur
local résoudrait le problème de la connexion Internet, mais il faudrait tout
de même faire tourner un serveur local sur la machine qui exécute le logiciel.

\paragraph{}
La solution que nous avons retenue est l’utilisation d’une base de donnée
intégrée à l’application. Ainsi, la création et la manipulation de la base
sera plus simple. Le principal inconvénient de ce type de base de données est
qu’on ne peut pas y accéder à plusieurs. Seul l’utilisateur du logiciel a accès
aux données qu’il manipule. Dans une amélioration possible du projet, on
pourrait imaginer installer la base de données sur un serveur externe pour
autoriser la multi-utilisation. Cette amélioration n’étant pas très compliquée,
il sera possible de la faire en fin de projet.

\paragraph{}
Il existe de nombreux SGBD, mais pour une base de données intégrée,
\href{https://sqlite.org/index.html}{SQLite} nous semble être le meilleur
choix. En effet, il est \textit{open source}, gratuit et est spécifiquement
destiné à être utilisé comme SGBD intégré à un logiciel. De plus, il est
simple d’utilisation car il existe une API Java permettant de le manipuler
simplement.

\subsection{Objectifs de la BDD}

Le principal objectif de la base de données est de pouvoir stocker les données
traitées par notre logiciel. Ainsi, il doit être possible de pouvoir stocker
des imagettes associées à leur transcription (vérité terrain). On devra
également pouvoir stocker les données obtenues par le système de reconnaissance
d’écriture manuscrite qui aura été entraîné grâce à la base d’apprentissage
que notre logiciel lui aura fourni. Ainsi, il faudra aussi stocker des
imagettes associées à leur transcription générée par le reconnaisseur.

\paragraph{}
En plus de stocker les données, la partie base de données devra pouvoir
communiquer facilement avec les autres blocs de notre logiciel (IHM et
préparateur de données). Le fait que nous utilisions SQLite et son
\textit{framework} Java va nous permettre d’implémenter des méthodes Java pour
accéder et manipuler simplement les données présentes dans la base. L’objectif
de l’équipe qui développe la base de données est donc de la modéliser, la
construire et de fournir une bibliothèque Java qui pourra être utilisée par le
reste de l’équipe. Le but de cette bibliothèque est d’éviter aux autres équipes
d’avoir à manipuler du SQL dans leur code Scala. Java étant interopérable avec
Scala, le fait de la développer en Java ne posera aucun problème pour le reste
du projet.

\subsection{Concernant la bibliothèque}

La bibliothèque que nous devons implémenter contiendra ainsi des méthodes dont
le but est de faire le lien entre la partie base de données et les autres
blocs du logiciel. Parmi ces méthodes, nous retrouverons ainsi des procédés
pour accéder aux données (\texttt{SELECT} en SQL), modifier les données
(\texttt{UPDATE} en SQL), insérer de nouvelles données dans la base
(\texttt{INSERT INTO} en SQL), ou encore supprimer des données de la base
(\texttt{DELETE} en SQL). Ces méthodes devront être implémentées pour chaque
table de la base de données.

\subsection{Modélisation}

Voici la manière dont nous avons modélisé la base de données (schéma en figure
6) :

\paragraph{}
Les tables \textbf{Author}, \textbf{Type} et \textbf{Operating Mode} permettent
de stocker les informations concerant les auteurs des documents, le type des
documents ainsi que le mode dans lequel on se trouve (mode apprentissage ou
mode évaluation). La table \textbf{Document} contient toutes les informations
concernant un document, à savoir : son nom, son auteur, son type, le mode auquel
il appartient, ainsi que sa date d’ajout à la base.
Nos imagettes seront stockées dans des dossiers à côté de la base de données.
Elles seront donc référencées par la base de données grâce à leur chemin
(\textit{e.g.} \texttt{/home/user/MesImagettes/imagette1.jpg}) dans la table
\textbf{Example}. Cette table contient en plus une référence vers le document
d’origine.

\paragraph{}
Les trois tables suivantes (\textbf{Transcription}, \textbf{UserAnnotation},
\textbf{GroundTruth}) servent à lier les imagettes avec leur transcription.
Dans la table \textbf{GroundTruth}, on enregistre l’identifiant de l’imagette
ainsi que sa vérité terrain. Dans la table \textbf{UserAnnotation}, on
enregistre la même chose mais, en plus, la date de création de cette vérité
terrain qui aura été ajoutée par un utilisateur. Enfin, dans la table
\textbf{Transcription}, on enregistre les mêmes informations que dans la
table \textbf{UserAnnotation} sauf que, cette fois-ci, la transcription aura
été donnée par un reconnaisseur d’écriture manuscrite représenté dans la
table \textbf{Recognizer}.

\newpage

\begin{mdframed}[frametitle={Figure 6 : Modèle entité association de la base de données}, innerbottommargin=10]
\begin{center}
\includegraphics[width=\linewidth]{Modele_entite_association.pdf}
\end{center}
\end{mdframed}

\section{Interface avec le reconnaisseur}

Cette partie du projet a pour but de faire le lien avec le système de
reconnaissance d’écriture. Située entre la BDD et le reconnaisseur,
l’interface permet de faire transiter des informations entre les deux, sans
contraintes de format. Elle convertit les données stockées en données
intelligibles pour le reconnaisseur (\textbf{INT\_FMT}).

\paragraph{}
Après discussion avec l'encadrant de projet, nous considérerons que le format
PiFF est connu des reconnaisseurs utilisés, \textit{i.e.} nous n'aurons pas à
écrire de convertisseur de PiFF vers un quelconque format d'entrée d'un
\textit{framework} de \textit{deep learning}. Par ailleurs, ceci permet de
rendre le projet totalement indépendant du \textit{framework}
(\textbf{GEN\_EVOL}). Après avoir transmis les données au reconnaisseur, nous
devrons cependant les récupérer pour traiter les résultats (\textbf{INT\_RES}).

\paragraph{}
Enfin, le logiciel à développer devra fonctionner dans les trois modes
(apprentissage, évaluation, production) qui ont été décrits dans une partie
précédente.