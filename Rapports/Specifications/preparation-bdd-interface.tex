\section{Préparation des données}

Cette partie du projet a pour but de réaliser un premier traitement sur les
données d’entrée. Ces données sont aux formats GEDI et PiFF, présentés dans
le dernier rapport. Nous devons fournir un logiciel qui soit capable de
traiter ces formats (\textbf{PR\_FO\_1} et \textbf{PR\_FO\_2}). Nous avons validé
la proposition que nous avions faite, qui était de choisir PiFF comme format
de traitement unique. Nous fournirons donc un convertisseur de GEDI vers PiFF,
et nous garantirons par modélisation logicielle la possibilité pour les futurs
utilisateurs d’écrire d’autres convertisseurs des formats de leur choix vers
PiFF s’ils le souhaitent (\textbf{GEN\_EVOL}).

\paragraph{}
En exploitant le fichier PiFF, ce module du projet génèrera les imagettes qui
formeront les exemples. Les coordonnées utilisées pour la découpe d’image seront
calculées grâce au polygone identifiant le paragraphe présent dans le fichier
d’entrée, ainsi que les détecteur de lignes. Cette découpe pourra être réalisée
soit en lignes, soit en paragraphes, ce qui correspond à deux reconnaisseurs
différents à utiliser par la suite. Par ailleurs, les fonctions de manipulation
d’images utiliseront la bibliothèque graphique \href{https://opencv.org}{OpenCV},
que nous avions déjà sélectionnée auparavant. Les deux options seront
disponibles sur le logiciel.

\paragraph{}
Nous devrons récupérer la vérité terrain si elle existe dans le fichier d’entrée,
afin de pouvoir l’afficher sur l’IHM et permettre à l’utilisateur de la corriger
ainsi qu’au reconnaisseur de s’entraîner avec, en lui fournissant des exemples
que notre logiciel aura créés en associant les imagettes à leur transcription.

\section{Stockage des données}

\subsection{Choix du type de modélisation}

Concernant le stockage des données, nous avions plusieurs choix :
\begin{itemize}
\item écrire dans des fichiers ;
\item installer une base de données sur un serveur distant ;
\item installer une base de données sur un serveur local à la machine ;
\item installer une base de données sans serveur, en interne au logiciel.
\end{itemize}

\paragraph{}
Pour éviter d’utiliser un système de base de données, nous aurions pu choisir
d’écrire les données que l’on voudrait sauvegarder directement dans des
fichiers. Cependant, cette façon de sauvegarder les données n’est pas très
“propre” et est compliquée à structurer. C’est pour cette raison que nous nous
sommes plutôt dirigés vers un Système de Gestion de Bases de Données (SGBD).

\paragraph{}
Utiliser un serveur distant sur lequel on installerait une base de données
était notre première idée. Cependant, ce système possède un inconvénient
majeur qui est que notre application aurait besoin d’une connexion Internet
et d’un serveur pour fonctionner. Cette contrainte ajoutant plus de complexité
que nécessaire, nous avons écarté cette possibilité. Utiliser un serveur
local résoudrait le problème de la connexion Internet, mais il faudrait tout
de même faire tourner un serveur local sur la machine qui exécute le logiciel.

\paragraph{}
La solution que nous avons retenue est l’utilisation d’une base de donnée
intégrée à l’application. Ainsi, la création et la manipulation de la base
sera plus simple. Le principal inconvénient de ce type de base de données est
qu’on ne peut pas y accéder à plusieurs. Seul l’utilisateur du logiciel a accès
aux données qu’il manipule. Dans une amélioration possible du projet, on
pourrait imaginer installer la base de données sur un serveur externe pour
autoriser la multi-utilisation. Cette amélioration n’étant pas très compliquée,
il sera possible de la faire en fin de projet.

\paragraph{}
Il existe de nombreux SGBD, mais pour une base de données intégrée,
\href{https://sqlite.org/index.html}{SQLite} nous semble être le meilleur
choix. En effet, il est \textit{open source}, gratuit et est spécifiquement
destiné à être utilisé comme SGBD intégré à un logiciel. De plus, il est
simple d’utilisation car il existe une API Java permettant de le manipuler
simplement.

\subsection{Objectifs de la BDD}

Le principal objectif de la base de données est de pouvoir stocker les données
traitées par notre logiciel. Ainsi, il doit être possible de pouvoir stocker
des imagettes associées à leur transcription (vérité terrain) (\textbf{BDD\_VER}).
On doit aussi pouvoir stocker des imagettes associées à une transcription établie
par l’utilisateur (\textbf{BDD\_USR}). On devra également pouvoir stocker les
données obtenues par le système de reconnaissance d’écriture manuscrite qui aura
été entraîné grâce à la base d’apprentissage que notre logiciel lui aura fourni.
Ainsi, il faudra aussi stocker des imagettes associées à leur transcription
générée par le reconnaisseur (\textbf{BDD\_REC}).

\paragraph{}
En plus de stocker les données, la partie base de données devra pouvoir
communiquer facilement avec les autres blocs de notre logiciel (IHM et
préparateur de données). Le fait que nous utilisions SQLite et son
\textit{framework} Java va nous permettre d’implémenter des méthodes Java pour
accéder et manipuler simplement les données présentes dans la base. L’objectif
de l’équipe qui développe la base de données est donc de la modéliser, la
construire et de fournir une bibliothèque Java qui pourra être utilisée par le
reste de l’équipe. Le but de cette bibliothèque est d’éviter aux autres équipes
d’avoir à manipuler du SQL dans leur code Scala. Java étant interopérable avec
Scala, le fait de la développer en Java ne posera aucun problème pour le reste
du projet.

\subsection{Concernant la bibliothèque}

La bibliothèque que nous devons implémenter contiendra ainsi des méthodes dont
le but est de faire le lien entre la partie base de données et les autres
blocs du logiciel. Parmi ces méthodes, nous retrouverons ainsi des procédés
pour accéder aux données (\textbf{BDD\_SEL}) (\texttt{SELECT} en SQL),
modifier les données (\textbf{BDD\_UPD}) (\texttt{UPDATE} en SQL), insérer de
nouvelles données dans la base (\textbf{BDD\_INS}) (\texttt{INSERT INTO} en
SQL), ou encore supprimer des données de la base (\textbf{BDD\_DEL})
(\texttt{DELETE} en SQL). Ces méthodes devront être implémentées pour chaque
table de la base de données.

\section{Interface avec le reconnaisseur}

Cette partie du projet a pour but de faire le lien avec le système de
reconnaissance d’écriture. Située entre la BDD et le reconnaisseur,
l’interface permet de faire transiter des informations entre les deux, sans
contraintes de format. Elle convertit les données stockées en données
intelligibles pour le reconnaisseur (\textbf{IR\_CV}).

\paragraph{}
Pour tester notre programme, nous avons un reconnaisseur d’écriture
manuscrite nommé
\href{https://github.com/jpuigcerver/Laia/tree/master/egs/iam}{Laia} à notre
disposition. Ce reconnaisseur prend en format d’entrée des fichiers dans un
format spécifique. Nous allons donc concevoir un programme qui transforme les
données stockées dans notre base au format adéquat pour que Laia puisse
apprendre. Notre programme ayant pour vocation à être utilisé par différents
systèmes de reconnaissance, nous allons laisser le code de ce programme
\textit{open source} pour que n’importe qui puisse définir son propre
formateur de données (\textbf{IR\_OS}).

\paragraph{}
Notre logiciel pourra également, via cette interface, lancer
l’apprentissage du système de reconnaissance (\textbf{IR\_AP}), lancer une
évaluation (\textbf{IR\_EV}) et lancer une transcription de document
(\textbf{IR\_TR}).